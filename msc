#!/bin/bash

# GitHub repository information
GITHUB_REPO="HelluPeptic/linux_msc"
VERSION_FILE="/usr/local/bin/.msc_version"
INSTALL_DIR="/usr/local/bin"

# Function to get current version (commit hash)
get_current_version() {
    if [ -f "$VERSION_FILE" ]; then
        cat "$VERSION_FILE"
    else
        echo "unknown"
    fi
}

# Function to get current commit timestamp
get_current_commit_timestamp() {
    local current_commit="$1"
    if [ "$current_commit" = "unknown" ]; then
        echo "1970-01-01T00:00:00Z"  # Very old date so everything appears as newer
        return
    fi
    
    # Get timestamp of current commit from GitHub API
    local commit_info=$(curl -s --connect-timeout 10 "https://api.github.com/repos/$GITHUB_REPO/commits/$current_commit" 2>/dev/null)
    if [ $? -eq 0 ] && [ -n "$commit_info" ]; then
        local timestamp=$(echo "$commit_info" | grep -o '"date": "[^"]*"' | head -1 | sed 's/"date": "\([^"]*\)"/\1/')
        if [ -n "$timestamp" ]; then
            echo "$timestamp"
        else
            echo "1970-01-01T00:00:00Z"
        fi
    else
        echo "1970-01-01T00:00:00Z"
    fi
}

# Function to compare timestamps (returns 0 if first timestamp is newer than second)
is_newer_timestamp() {
    local timestamp1="$1"
    local timestamp2="$2"
    
    # Convert to seconds since epoch for comparison
    local time1=$(date -d "$timestamp1" +%s 2>/dev/null || echo "0")
    local time2=$(date -d "$timestamp2" +%s 2>/dev/null || echo "0")
    
    # Return true (0) if timestamp1 is newer than timestamp2
    [ "$time1" -gt "$time2" ]
}

# Function to get all branches from repository
get_all_branches() {
    # Get all branches from GitHub API
    curl -s --connect-timeout 10 "https://api.github.com/repos/$GITHUB_REPO/branches" 2>/dev/null | \
    grep -o '"name": "[^"]*"' | \
    sed 's/"name": "\([^"]*\)"/\1/' | \
    head -20  # Limit to prevent too many API calls
}

# Function to check for updates
check_for_updates() {
    dialog --infobox "Checking for updates..." 8 40
    
    local current_version=$(get_current_version)
    local temp_file="/tmp/msc_updates"
    
    # Clear temp file
    > "$temp_file"
    
    # Test connectivity first
    if ! curl -s --connect-timeout 5 "https://api.github.com" >/dev/null 2>&1; then
        dialog --msgbox "Cannot connect to GitHub API.\\n\\nPlease check your internet connection and try again." 10 50
        return
    fi
    
    # Get current commit timestamp for comparison
    local current_timestamp=$(get_current_commit_timestamp "$current_version")
    
    # Get all available branches dynamically
    local branches=$(get_all_branches)
    if [ -z "$branches" ]; then
        dialog --msgbox "Could not fetch branch information from GitHub.\\n\\nPlease try again later." 10 50
        return
    fi
    
    # Check each branch for newer commits
    while IFS= read -r branch; do
        [ -z "$branch" ] && continue
        
        # Get recent commits from this branch (last 5)
        local commits_data=$(curl -s --connect-timeout 10 "https://api.github.com/repos/$GITHUB_REPO/commits?sha=$branch&per_page=5" 2>/dev/null)
        if [ $? -ne 0 ] || [ -z "$commits_data" ]; then
            continue
        fi
        
        # Find the newest commit from this branch that's newer than current
        local found_newer=false
        local commit_shas=$(echo "$commits_data" | grep -o '"sha": "[^"]*"' | sed 's/"sha": "\([^"]*\)"/\1/')
        
        for commit_hash in $commit_shas; do
            # Skip if same as current version
            if [ "$commit_hash" = "$current_version" ]; then
                continue
            fi
            
            # Get this commit's timestamp and message
            local commit_timestamp=$(echo "$commits_data" | grep -A20 "\"sha\": \"$commit_hash\"" | grep -m1 '"date":' | sed 's/.*"date": "\([^"]*\)".*/\1/')
            local commit_message=$(echo "$commits_data" | sed -n "/\"sha\": \"$commit_hash\"/,/\"message\":/p" | grep '"message":' | sed 's/.*"message": "\([^"]*\)".*/\1/' | head -c50)
            
            # Only include if this commit is newer than current
            if [ -n "$commit_timestamp" ] && is_newer_timestamp "$commit_timestamp" "$current_timestamp"; then
                # Format date for display
                local display_date=$(date -d "$commit_timestamp" "+%b %d, %Y %H:%M" 2>/dev/null || echo "Recent")
                
                # Mark experimental branches (anything other than main)
                local branch_marker=""
                if [ "$branch" != "main" ]; then
                    branch_marker="[EXPERIMENTAL] "
                fi
                
                echo "$commit_hash|$commit_message|$branch|$display_date|$branch_marker" >> "$temp_file"
                found_newer=true
                break  # Only take the newest commit per branch
            fi
        done
    done <<< "$branches"
    
    # Check if we found any updates
    if [ ! -s "$temp_file" ]; then
        dialog --msgbox "You're up to date!\\n\\nNo newer commits found.\\n\\nCurrent version: ${current_version:0:8}" 10 50
        rm -f "$temp_file"
        return
    fi
    
    # Show available updates
    show_update_menu "$temp_file" "$current_version"
    rm -f "$temp_file"
}

# Function to show update selection menu
show_update_menu() {
    local updates_file="$1"
    local current_version="$2"
    local menu_items=()
    local commit_data=()
    local counter=1
    
    while IFS='|' read -r commit_hash commit_message branch display_date branch_marker; do
        
        # Create user-friendly display with experimental marking and commit hash
        local short_hash="${commit_hash:0:8}"
        local display_text
        
        # Use the branch marker from the data
        if [ -z "$commit_message" ] || [ "$commit_message" = "" ]; then
            display_text="${branch_marker}Commit $short_hash ($display_date - $branch)"
        else
            display_text="${branch_marker}$commit_message [$short_hash] ($display_date - $branch)"
        fi
        
        menu_items+=("$counter" "$display_text")
        commit_data["$counter"]="$commit_hash|$commit_message|$branch"
        counter=$((counter + 1))
    done < "$updates_file"
    
    if [ ${#menu_items[@]} -eq 0 ]; then
        dialog --msgbox "No updates found." 8 40
        return
    fi
    
    local selection=$(dialog --menu "Available Versions:\n\nSelect a version to install (current: ${current_version:0:8}):" 20 100 8 "${menu_items[@]}" 3>&1 1>&2 2>&3)
    
    if [ -n "$selection" ] && [ -n "${commit_data[$selection]}" ]; then
        IFS='|' read -r selected_commit selected_message selected_branch <<< "${commit_data[$selection]}"
        
        # Show confirmation dialog with experimental warning
        local branch_warning=""
        if [ "$selected_branch" != "main" ]; then
            branch_warning="\n\nWARNING: This is an experimental branch!\nIt may contain unstable features or bugs."
        fi
        
        if dialog --yesno "Install update?\n\nCommit: ${selected_commit:0:8}\nMessage: $selected_message\nBranch: $selected_branch$branch_warning\n\nThis will update your msc installation." 15 70; then
            install_update "$selected_commit" "$selected_branch"
        fi
    fi
}

# Function to install update
install_update() {
    local commit_hash="$1"
    local branch="$2"
    local clean_branch=$(echo "$branch" | sed 's/ \[EXPERIMENTAL\]//')
    
    {
        echo "10" ; echo "Downloading update..."
        
        # Create temporary directory
        local temp_dir=$(mktemp -d)
        cd "$temp_dir" || exit 1
        
        echo "30" ; echo "Extracting files..."
        
        # Download the specific commit
        if ! curl -L -s "https://github.com/$GITHUB_REPO/archive/$commit_hash.tar.gz" | tar -xz; then
            dialog --msgbox "Failed to download update. Please check your internet connection." 10 50
            rm -rf "$temp_dir"
            return 1
        fi
        
        echo "60" ; echo "Installing files..."
        
        # Find the extracted directory
        local extracted_dir=$(find . -maxdepth 1 -type d -name "*linux_msc*" | head -1)
        if [ -z "$extracted_dir" ]; then
            # Fallback: look for any directory that's not . or ..
            extracted_dir=$(ls -d */ 2>/dev/null | head -1 | sed 's|/$||')
        fi
        
        if [ -z "$extracted_dir" ]; then
            dialog --msgbox "Failed to extract update files." 10 50
            rm -rf "$temp_dir"
            return 1
        fi
        
        echo "80" ; echo "Updating installation..."
        
        # Copy files to installation directory
        cd "$extracted_dir" || exit 1
        sudo cp -r * "$INSTALL_DIR/"
        
        # Make scripts executable
        sudo chmod +x "$INSTALL_DIR/msc" "$INSTALL_DIR/msc-servers.sh" "$INSTALL_DIR/msc-create.sh"
        sudo chmod +x "$INSTALL_DIR/create_scripts/"*.sh
        
        echo "95" ; echo "Saving version info..."
        
        # Save new version
        sudo bash -c "echo '$commit_hash' > '$VERSION_FILE'"
        
        echo "100" ; echo "Update complete!"
        
        # Cleanup
        cd /
        rm -rf "$temp_dir"
        
    } | dialog --gauge "Installing Update..." 10 60 0
    
    dialog --msgbox "Update installed successfully!\n\nNew version: ${commit_hash:0:8}\nBranch: $clean_branch\n\nPlease restart msc to use the new version." 12 60
}

# Function to display the menu
show_menu() {
    dialog --clear --title "Minecraft Server Control" --menu "Choose an option:" 17 55 3 \
        1 "Manage Minecraft Servers" \
        2 "Create a New Minecraft Server" \
        3 "Check for Updates" 2> /tmp/msc_menu_choice

    local choice
    choice=$(< /tmp/msc_menu_choice)
    rm -f /tmp/msc_menu_choice

    case "$choice" in
        1)
            # Run the msc-servers.sh script
            bash msc-servers.sh
            ;;
        2)
            # Run the msc-create.sh script
            bash msc-create.sh
            ;;
        3)
            # Check for updates
            check_for_updates
            ;;
        *)
            # If cancelled or closed, do nothing
            clear
            echo "Exited menu."
            ;;
    esac
}

# Main execution
clear
show_menu
